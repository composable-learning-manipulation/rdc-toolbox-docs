\begin{lstlisting}[caption=\raggedright{mcu-libs/RLS.h}, frame=single]

#include <sensor_self_diagnostic.h>

uint16_t SELF_DIAGNOSTIC_STATE = 0x000; // Bitmask code error for SelfDiagnosticCode

SelfDiagnosticCode checkSensorMount(SelfDiagnosticInputState &input_state)
{
    if (signbit(input_state.w[SD_REQUIRED_BUFF_SIZE - 1]) != signbit(input_state.w_est[SD_REQUIRED_BUFF_SIZE - 1]))
        return SENSOR_MOUNT_ERROR;
    return OK;
}

SelfDiagnosticCode checkExcessAirGap(SelfDiagnosticInputState &input_state, const SelfDiagnosticParams &diagnostic_params, RLS * rls)
{
    // RLSQ Estimation of R L and lambda_m
    Matrix *X = createMatrix(3, 1);
    for (int i = 0; i < SD_REQUIRED_BUFF_SIZE; i++)
    {
        X->data[0][0] = -input_state.i_ab[i];
        X->data[1][0] = input_state.di_ab[i];
        X->data[2][0] = -diagnostic_params.n_p * sin(diagnostic_params.n_p * input_state.theta[i]);
        addObs(rls, X, input_state.u_ab[i]);

        X->data[0][0] = -input_state.i_ab[SD_REQUIRED_BUFF_SIZE + i];
        X->data[1][0] = input_state.di_ab[SD_REQUIRED_BUFF_SIZE + i];
        X->data[2][0] = diagnostic_params.n_p * cos(diagnostic_params.n_p * input_state.theta[i]);
        addObs(rls, X, input_state.u_ab[SD_REQUIRED_BUFF_SIZE + i]);
    }
    freeMatrix(X);

    // rls->w = [R, L, lambda_m]^T

    //  Calculate air gap between rotor and stator
    float delta[2] = {
        (input_state.i_ab[SD_REQUIRED_BUFF_SIZE-1]*diagnostic_params.coilNTurns*diagnostic_params.mu0)/(
                (*(rls->w))(0,1)*input_state.i_ab[SD_REQUIRED_BUFF_SIZE-1] +
                (*(rls->w))(0,2)*cos(diagnostic_params.n_p *input_state.theta[SD_REQUIRED_BUFF_SIZE-1])
        ),
        (input_state.i_ab[2*SD_REQUIRED_BUFF_SIZE-1]*diagnostic_params.coilNTurns*diagnostic_params.mu0)/(
                (*(rls->w))(0,1)*input_state.i_ab[2*SD_REQUIRED_BUFF_SIZE-1] +
                (*(rls->w))(0,2)*sin(diagnostic_params.n_p *input_state.theta[SD_REQUIRED_BUFF_SIZE-1])
        )
    };
    delta[0] -= diagnostic_params.statorWireLen/(diagnostic_params.mu*diagnostic_params.statorCoreArea);
    delta[1] -= diagnostic_params.statorWireLen/(diagnostic_params.mu*diagnostic_params.statorCoreArea);
    delta[0] *= diagnostic_params.magnetCoreArea;
    delta[1] *= diagnostic_params.magnetCoreArea;
    if (delta[0] >= diagnostic_params.maxAirGap) return EXCESS_AIR_GAP_ERROR;
    if (delta[1] >= diagnostic_params.maxAirGap) return EXCESS_AIR_GAP_ERROR;
    return OK;
}

SelfDiagnosticCode FFT_torque_vibration_check(
        SelfDiagnosticInputState &input_state,
        const SelfDiagnosticParams &diagnostic_params,
        RFFT_F32_STRUCT_Handle & hnd_rfft
){
    while(flagInputReady == 0){return OK;};  // Wait on Buffer will be full to set the flag
                                   // before proceeding
    // Apply the window (float) to the input (uint16_t)
    memcpy(&test_input, &input_state.magnet_torque_est, TEST_SIZE);
    RFFT_adc_f32_win(test_input, fftWindow, FFT_SIZE );
    RFFT_f32_mag_TMU0(hnd_rfft);            //Calculate magnitude
    uint16_t min_freq = (uint16_t)(fabsf(diagnostic_params.wMin)*diagnostic_params.dt/(2*M_PI));
    uint16_t max_freq = (uint16_t)(diagnostic_params.wMax*diagnostic_params.dt/(2*M_PI));
    if(max_freq>(hnd_rfft->FFTSize)) max_freq = hnd_rfft->FFTSize;
    for (uint16_t i = min_freq; i<max_freq; i++){
        if(hnd_rfft->MagBuf[i] > diagnostic_params.maxHighFreqTorqueMagnitude) return SHAFT_VIBRATION_ERROR;
    }
    return OK;

}



void fullInitCheck(SelfDiagnosticInputState & input_state, uint16_t & self_diagnostic_state,
                   const SelfDiagnosticParams & diagnostic_params
){
    while(
        input_state.w[SD_REQUIRED_BUFF_SIZE-1]<diagnostic_params.wMin &&
        input_state.w[SD_REQUIRED_BUFF_SIZE-1]>diagnostic_params.wMax
    ) {
    //  Delay for 1 second
        DEVICE_DELAY_US(100000);
    };
    //  Calculate bitmask for error
    //  Check sensorMount error
    self_diagnostic_state |= checkSensorMount(input_state);
    //  Check airGap exceeding value. Initializing recurrent least square
    RLS *rls = createRLS(3, 0.7, 1.0);
    self_diagnostic_state |= checkExcessAirGap(input_state, diagnostic_params, rls);
}

void fullRuntimeCheck(SelfDiagnosticInputState &input_state,
                      uint16_t &self_diagnostic_state,
                      const SelfDiagnosticParams &diagnostic_params)
{

    // Object of the structure RFFT_F32_STRUCT
    RFFT_F32_STRUCT rfft;
    // Handle to the RFFT_F32_STRUCT object
    RFFT_F32_STRUCT_Handle hnd_rfft = &rfft;
    //  Do FFT for estimating Mag-Freq dependency
    self_diagnostic_state |= FFT_torque_vibration_check(input_state, diagnostic_params, hnd_rfft);

}

\end{lstlisting}