\begin{lstlisting}[caption=\raggedright{mcu-libs/Matrix.cpp}, frame=single]
#include "Matrix.h"

Matrix *createMatrix(int rows, int cols)
{
    Matrix *matrix = (Matrix *)malloc(sizeof(Matrix));
    matrix->rows = rows;
    matrix->cols = cols;
    matrix->data = (float **)malloc(rows * sizeof(float *));
    for (int i = 0; i < rows; i++)
    {
        matrix->data[i] = (float *)malloc(cols * sizeof(float));
    }
    return matrix;
}

void freeMatrix(Matrix *matrix)
{
    for (int i = 0; i < matrix->rows; i++)
    {
        free(matrix->data[i]);
    }
    free(matrix->data);
    free(matrix);
}

void printMatrix(Matrix *matrix)
{
    for (int i = 0; i < matrix->rows; i++)
    {
        for (int j = 0; j < matrix->cols; j++)
        {
            printf("%f ", matrix->data[i][j]);
        }
        printf("\n");
    }
}

Matrix *matrixProduct(Matrix *A, Matrix *B)
{
    assert(A->cols == B->rows);
    Matrix *C = createMatrix(A->rows, B->cols);
    for (int i = 0; i < A->rows; i++)
    {
        for (int j = 0; j < B->cols; j++)
        {
            C->data[i][j] = 0;
            for (int k = 0; k < A->cols; k++)
            {
                C->data[i][j] += A->data[i][k] * B->data[k][j];
            }
        }
    }
    return C;
}

Matrix *transposeMatrix(Matrix *matrix)
{
    Matrix *transposed = createMatrix(matrix->cols, matrix->rows);
    for (int i = 0; i < matrix->rows; i++)
    {
        for (int j = 0; j < matrix->cols; j++)
        {
            transposed->data[j][i] = matrix->data[i][j];
        }
    }
    return transposed;
}

Matrix *getMatrixMinor(Matrix *matrix, int row, int col)
{
    Matrix *minor = createMatrix(matrix->rows - 1, matrix->cols - 1);
    for (int i = 0, mi = 0; i < matrix->rows; i++)
    {
        if (i == row)
            continue;
        for (int j = 0, mj = 0; j < matrix->cols; j++)
        {
            if (j == col)
                continue;
            minor->data[mi][mj] = matrix->data[i][j];
            mj++;
        }
        mi++;
    }
    return minor;
}

float getMatrixDeterminant(Matrix *matrix)
{
    if (matrix->rows == 2 && matrix->cols == 2)
    {
        return matrix->data[0][0] * matrix->data[1][1] - matrix->data[0][1] * matrix->data[1][0];
    }

    float determinant = 0;
    for (int c = 0; c < matrix->cols; c++)
    {
        Matrix *minor = getMatrixMinor(matrix, 0, c);
        determinant += ((c % 2 == 0) ? 1 : -1) * matrix->data[0][c] * getMatrixDeterminant(minor);
        freeMatrix(minor);
    }
    return determinant;
}

Matrix *getMatrixInverse(Matrix *matrix)
{
    float determinant = getMatrixDeterminant(matrix);
    assert(determinant != 0);

    if (matrix->rows == 2 && matrix->cols == 2)
    {
        Matrix *inverse = createMatrix(2, 2);
        inverse->data[0][0] = matrix->data[1][1] / determinant;
        inverse->data[0][1] = -matrix->data[0][1] / determinant;
        inverse->data[1][0] = -matrix->data[1][0] / determinant;
        inverse->data[1][1] = matrix->data[0][0] / determinant;
        return inverse;
    }

    Matrix *cofactors = createMatrix(matrix->rows, matrix->cols);
    for (int r = 0; r < matrix->rows; r++)
    {
        for (int c = 0; c < matrix->cols; c++)
        {
            Matrix *minor = getMatrixMinor(matrix, r, c);
            cofactors->data[r][c] = ((r + c) % 2 == 0 ? 1 : -1) * getMatrixDeterminant(minor);
            freeMatrix(minor);
        }
    }
    Matrix *transposedCofactors = transposeMatrix(cofactors);
    // TODO: replace with func of multiplication
    for (int r = 0; r < transposedCofactors->rows; r++)
    {
        for (int c = 0; c < transposedCofactors->cols; c++)
        {
            transposedCofactors->data[r][c] /= determinant;
        }
    }
    freeMatrix(cofactors);
    return transposedCofactors;
}

Matrix *addScalarToMatrix(Matrix *matrix, float scalar)
{
    Matrix *result = createMatrix(matrix->rows, matrix->cols);
    for (int i = 0; i < matrix->rows; i++)
    {
        for (int j = 0; j < matrix->cols; j++)
        {
            result->data[i][j] = matrix->data[i][j] + scalar;
        }
    }
    return result;
}

Matrix *multiplyScalarToMatrix(Matrix *matrix, float scalar)
{
    Matrix *result = createMatrix(matrix->rows, matrix->cols);
    for (int i = 0; i < matrix->rows; i++)
    {
        for (int j = 0; j < matrix->cols; j++)
        {
            result->data[i][j] = matrix->data[i][j] * scalar;
        }
    }
    return result;
}

Matrix *addMatrices(Matrix *matrix1, Matrix *matrix2)
{
    assert(matrix1->rows == matrix2->rows && matrix1->cols == matrix2->cols);
    Matrix *result = createMatrix(matrix1->rows, matrix1->cols);
    for (int i = 0; i < matrix1->rows; i++)
    {
        for (int j = 0; j < matrix1->cols; j++)
        {
            result->data[i][j] = matrix1->data[i][j] + matrix2->data[i][j];
        }
    }
    return result;
}
\end{lstlisting}